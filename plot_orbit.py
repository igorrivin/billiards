#!/usr/bin/env python3
"""
Plot billiard orbits in Lp balls with signature and rotation number information.

This program visualizes orbits from various sources:
- CSV files generated by newton4.py
- Command line input
- JSON files
"""

import numpy as np
import matplotlib.pyplot as plt
import argparse
import json
import pandas as pd
import ast


def curve(t, p, eps_pow=1e-14, n_points=1000):
    """Generate points on the Lp superellipse boundary."""
    ang = 2 * np.pi * t
    q = 2.0 / p
    c, s = np.cos(ang), np.sin(ang)
    
    def pow_func(x):
        return np.sign(x) * (np.abs(x) + eps_pow) ** q
    
    return np.column_stack([pow_func(c), pow_func(s)])


def rotation_number(theta):
    """Compute rotation number of an orbit by analyzing the permutation."""
    theta = np.array(theta)
    n = len(theta)
    
    # Get the permutation
    sorted_indices = np.argsort(theta)
    
    # Inverse permutation
    position = np.empty(n, dtype=int)
    position[sorted_indices] = np.arange(n)
    
    # Follow the orbit and count total rotation
    total_rotation = 0
    current_pos = position[0]
    
    for i in range(n):
        next_i = (i + 1) % n
        next_pos = position[next_i]
        
        # How far did we rotate?
        if next_pos >= current_pos:
            step = next_pos - current_pos
        else:
            step = n + next_pos - current_pos
            
        total_rotation += step
        current_pos = next_pos
    
    # The rotation number
    k = total_rotation // n
    
    from math import gcd
    g = gcd(k, n)
    return k // g, n // g


def plot_orbit(theta, p, signature=None, rot_num=None, rot_den=None, 
               title=None, save_file=None, show=True):
    """Plot a single orbit in the Lp ball."""
    # Convert theta to numpy array
    theta = np.array(theta, dtype=float)
    
    # Create figure
    fig, ax = plt.subplots(1, 1, figsize=(8, 8))
    
    # Draw the Lp boundary
    t_boundary = np.linspace(0, 1, 1000, endpoint=False)
    boundary = curve(t_boundary, p)
    ax.plot(boundary[:, 0], boundary[:, 1], 'k-', linewidth=2, alpha=0.5, label=f'L{p} ball')
    
    # Get orbit points
    orbit_points = curve(theta, p)
    
    # Plot the orbit polygon
    closed_orbit = np.vstack([orbit_points, orbit_points[0]])
    ax.plot(closed_orbit[:, 0], closed_orbit[:, 1], 'b-', linewidth=2, alpha=0.8)
    
    # Plot bounce points
    ax.plot(orbit_points[:, 0], orbit_points[:, 1], 'ro', markersize=8)
    
    # Number the bounce points
    for i, (x, y) in enumerate(orbit_points):
        ax.annotate(str(i+1), (x, y), xytext=(5, 5), textcoords='offset points')
    
    # Create legend text
    legend_parts = []
    if signature is not None:
        legend_parts.append(f"Signature: {signature}")
    
    if rot_num is not None and rot_den is not None:
        legend_parts.append(f"Rotation: {rot_num}/{rot_den}")
    elif theta is not None:
        # Compute rotation number if not provided
        r_num, r_den = rotation_number(theta)
        legend_parts.append(f"Rotation: {r_num}/{r_den}")
    
    if legend_parts:
        legend_text = ", ".join(legend_parts)
        ax.plot([], [], 'b-', linewidth=2, label=legend_text)
    
    # Set equal aspect ratio and limits
    ax.set_aspect('equal')
    ax.set_xlim(-1.2, 1.2)
    ax.set_ylim(-1.2, 1.2)
    ax.grid(True, alpha=0.3)
    ax.legend(loc='upper right')
    
    if title:
        ax.set_title(title)
    else:
        ax.set_title(f"Billiard Orbit in L{p} Ball (N={len(theta)})")
    
    plt.tight_layout()
    
    if save_file:
        plt.savefig(save_file, dpi=300, bbox_inches='tight')
        print(f"Saved plot to {save_file}")
    
    if show:
        plt.show()
    
    return fig, ax


def parse_theta_string(theta_str):
    """Parse theta from various string formats."""
    theta_str = theta_str.strip()
    
    # Try JSON format
    if theta_str.startswith('[') and theta_str.endswith(']'):
        try:
            return json.loads(theta_str)
        except json.JSONDecodeError:
            pass
    
    # Try tuple format (from CSV)
    if theta_str.startswith('(') and theta_str.endswith(')'):
        try:
            return list(ast.literal_eval(theta_str))
        except:
            pass
    
    # Try comma-separated
    try:
        return [float(x.strip()) for x in theta_str.split(',')]
    except:
        raise ValueError(f"Could not parse theta string: {theta_str}")


def main():
    parser = argparse.ArgumentParser(
        description='Plot billiard orbits in Lp balls',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Input sources (in order of precedence):
  1. --csv FILE: Read from newton4.py output (can select by row)
  2. --theta: Direct input of bounce points
  3. --json FILE: Read orbit data from JSON file

Examples:
  # From CSV file (row 5)
  %(prog)s --csv p3.0_N5_orbits.csv --row 5
  
  # Direct input
  %(prog)s --p 3.0 --theta "0.0657,0.375,0.6843"
  
  # From CSV, plot multiple orbits
  %(prog)s --csv p3.0_N5_orbits.csv --rows 1,5,10 --grid
        """)
    
    # Input sources
    parser.add_argument('--csv', help='CSV file from newton4.py')
    parser.add_argument('--row', type=int, help='Row number in CSV (1-based)')
    parser.add_argument('--rows', help='Multiple rows (comma-separated)')
    parser.add_argument('--theta', help='Direct theta input')
    parser.add_argument('--json', help='JSON file with orbit data')
    
    # Parameters
    parser.add_argument('--p', type=float, help='Shape parameter (required if not in CSV)')
    
    # Output options
    parser.add_argument('--save', help='Save plot to file')
    parser.add_argument('--no-show', action='store_true', help='Do not display plot')
    parser.add_argument('--grid', action='store_true', help='Plot multiple orbits in grid')
    parser.add_argument('--title', help='Custom plot title')
    
    args = parser.parse_args()
    
    orbits = []
    
    if args.csv:
        # Read from CSV
        df = pd.read_csv(args.csv)
        
        # Extract p from filename if not provided
        if args.p is None:
            import re
            match = re.search(r'p(\d+\.?\d*)_', args.csv)
            if match:
                args.p = float(match.group(1))
            else:
                print("Error: Could not extract p from filename. Use --p to specify.")
                return 1
        
        if args.rows:
            # Multiple rows
            row_indices = [int(r.strip())-1 for r in args.rows.split(',')]
            for idx in row_indices:
                if 0 <= idx < len(df):
                    row = df.iloc[idx]
                    theta = parse_theta_string(row['theta'])
                    sig = (row['pos'], row['neg'], row['zero'])
                    orbits.append({
                        'theta': theta,
                        'signature': sig,
                        'rot_num': row.get('rot_num'),
                        'rot_den': row.get('rot_den'),
                        'row': idx + 1
                    })
        elif args.row:
            # Single row
            idx = args.row - 1
            if 0 <= idx < len(df):
                row = df.iloc[idx]
                theta = parse_theta_string(row['theta'])
                sig = (row['pos'], row['neg'], row['zero'])
                orbits.append({
                    'theta': theta,
                    'signature': sig,
                    'rot_num': row.get('rot_num'),
                    'rot_den': row.get('rot_den'),
                    'row': args.row
                })
            else:
                print(f"Error: Row {args.row} out of range (file has {len(df)} rows)")
                return 1
        else:
            # Default to first few interesting orbits
            print(f"No row specified. Showing first orbit. File has {len(df)} rows.")
            row = df.iloc[0]
            theta = parse_theta_string(row['theta'])
            sig = (row['pos'], row['neg'], row['zero'])
            orbits.append({
                'theta': theta,
                'signature': sig,
                'rot_num': row.get('rot_num'),
                'rot_den': row.get('rot_den'),
                'row': 1
            })
    
    elif args.theta:
        # Direct theta input
        if args.p is None:
            print("Error: --p required when using --theta")
            return 1
        
        theta = parse_theta_string(args.theta)
        orbits.append({'theta': theta})
    
    elif args.json:
        # JSON file input
        with open(args.json, 'r') as f:
            data = json.load(f)
        
        if 'theta' in data:
            # Single orbit
            orbits.append(data)
            if args.p is None and 'p' in data:
                args.p = data['p']
        elif 'orbits' in data:
            # Multiple orbits
            orbits.extend(data['orbits'])
            if args.p is None and 'p' in data:
                args.p = data['p']
    
    else:
        print("Error: Need input source (--csv, --theta, or --json)")
        parser.print_help()
        return 1
    
    if args.p is None:
        print("Error: Shape parameter p not specified")
        return 1
    
    # Plot orbits
    if len(orbits) == 1:
        # Single plot
        orbit = orbits[0]
        title = args.title
        if title is None and 'row' in orbit:
            title = f"Orbit from row {orbit['row']}"
        
        plot_orbit(
            orbit['theta'], args.p,
            signature=orbit.get('signature'),
            rot_num=orbit.get('rot_num'),
            rot_den=orbit.get('rot_den'),
            title=title,
            save_file=args.save,
            show=not args.no_show
        )
    
    elif args.grid and len(orbits) > 1:
        # Grid plot
        n_orbits = len(orbits)
        n_cols = int(np.ceil(np.sqrt(n_orbits)))
        n_rows = int(np.ceil(n_orbits / n_cols))
        
        fig, axes = plt.subplots(n_rows, n_cols, figsize=(4*n_cols, 4*n_rows))
        if n_rows == 1:
            axes = axes.reshape(1, -1)
        elif n_cols == 1:
            axes = axes.reshape(-1, 1)
        
        for i, orbit in enumerate(orbits):
            row = i // n_cols
            col = i % n_cols
            ax = axes[row, col]
            
            # Draw boundary
            t_boundary = np.linspace(0, 1, 1000, endpoint=False)
            boundary = curve(t_boundary, args.p)
            ax.plot(boundary[:, 0], boundary[:, 1], 'k-', linewidth=1, alpha=0.5)
            
            # Draw orbit
            orbit_theta = np.array(orbit['theta'], dtype=float)
            orbit_points = curve(orbit_theta, args.p)
            closed_orbit = np.vstack([orbit_points, orbit_points[0]])
            ax.plot(closed_orbit[:, 0], closed_orbit[:, 1], 'b-', linewidth=1.5)
            ax.plot(orbit_points[:, 0], orbit_points[:, 1], 'ro', markersize=4)
            
            # Title with info
            title_parts = []
            if 'row' in orbit:
                title_parts.append(f"Row {orbit['row']}")
            if 'signature' in orbit:
                title_parts.append(f"Sig: {orbit['signature']}")
            if 'rot_num' in orbit and 'rot_den' in orbit:
                title_parts.append(f"Rot: {orbit['rot_num']}/{orbit['rot_den']}")
            
            ax.set_title('\n'.join(title_parts), fontsize=10)
            ax.set_aspect('equal')
            ax.set_xlim(-1.2, 1.2)
            ax.set_ylim(-1.2, 1.2)
            ax.axis('off')
        
        # Hide empty subplots
        for i in range(n_orbits, n_rows * n_cols):
            row = i // n_cols
            col = i % n_cols
            axes[row, col].axis('off')
        
        plt.tight_layout()
        
        if args.save:
            plt.savefig(args.save, dpi=300, bbox_inches='tight')
            print(f"Saved grid plot to {args.save}")
        
        if not args.no_show:
            plt.show()
    
    else:
        # Multiple individual plots
        for i, orbit in enumerate(orbits):
            title = args.title
            if title is None and 'row' in orbit:
                title = f"Orbit from row {orbit['row']}"
            
            save_file = None
            if args.save:
                base, ext = args.save.rsplit('.', 1)
                save_file = f"{base}_{i+1}.{ext}"
            
            plot_orbit(
                orbit['theta'], args.p,
                signature=orbit.get('signature'),
                rot_num=orbit.get('rot_num'),
                rot_den=orbit.get('rot_den'),
                title=title,
                save_file=save_file,
                show=not args.no_show
            )
    
    return 0


if __name__ == "__main__":
    exit(main())